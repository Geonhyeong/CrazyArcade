// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#include "Protocol.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Protocol {
PROTOBUF_CONSTEXPR S_EnterGame::S_EnterGame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.player_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_EnterGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EnterGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EnterGameDefaultTypeInternal() {}
  union {
    S_EnterGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EnterGameDefaultTypeInternal _S_EnterGame_default_instance_;
PROTOBUF_CONSTEXPR S_LeaveGame::S_LeaveGame(
    ::_pbi::ConstantInitialized) {}
struct S_LeaveGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_LeaveGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_LeaveGameDefaultTypeInternal() {}
  union {
    S_LeaveGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_LeaveGameDefaultTypeInternal _S_LeaveGame_default_instance_;
PROTOBUF_CONSTEXPR S_Spawn::S_Spawn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objects_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_SpawnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_SpawnDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_SpawnDefaultTypeInternal() {}
  union {
    S_Spawn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_SpawnDefaultTypeInternal _S_Spawn_default_instance_;
PROTOBUF_CONSTEXPR S_Despawn::S_Despawn(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectids_)*/{}
  , /*decltype(_impl_._objectids_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_DespawnDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_DespawnDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_DespawnDefaultTypeInternal() {}
  union {
    S_Despawn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_DespawnDefaultTypeInternal _S_Despawn_default_instance_;
PROTOBUF_CONSTEXPR C_Move::C_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.posinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_MoveDefaultTypeInternal() {}
  union {
    C_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_MoveDefaultTypeInternal _C_Move_default_instance_;
PROTOBUF_CONSTEXPR S_Move::S_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.posinfo_)*/nullptr
  , /*decltype(_impl_.objectid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_MoveDefaultTypeInternal() {}
  union {
    S_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_MoveDefaultTypeInternal _S_Move_default_instance_;
PROTOBUF_CONSTEXPR C_Skill::C_Skill(
    ::_pbi::ConstantInitialized) {}
struct C_SkillDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_SkillDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_SkillDefaultTypeInternal() {}
  union {
    C_Skill _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_SkillDefaultTypeInternal _C_Skill_default_instance_;
PROTOBUF_CONSTEXPR S_ChangeStat::S_ChangeStat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.statinfo_)*/nullptr
  , /*decltype(_impl_.playerid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_ChangeStatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_ChangeStatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_ChangeStatDefaultTypeInternal() {}
  union {
    S_ChangeStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_ChangeStatDefaultTypeInternal _S_ChangeStat_default_instance_;
PROTOBUF_CONSTEXPR S_Pop::S_Pop(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objectid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_PopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_PopDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_PopDefaultTypeInternal() {}
  union {
    S_Pop _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_PopDefaultTypeInternal _S_Pop_default_instance_;
PROTOBUF_CONSTEXPR S_Trap::S_Trap(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_TrapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_TrapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_TrapDefaultTypeInternal() {}
  union {
    S_Trap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_TrapDefaultTypeInternal _S_Trap_default_instance_;
PROTOBUF_CONSTEXPR S_Die::S_Die(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_DieDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_DieDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_DieDefaultTypeInternal() {}
  union {
    S_Die _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_DieDefaultTypeInternal _S_Die_default_instance_;
PROTOBUF_CONSTEXPR S_Connected::S_Connected(
    ::_pbi::ConstantInitialized) {}
struct S_ConnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_ConnectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_ConnectedDefaultTypeInternal() {}
  union {
    S_Connected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_ConnectedDefaultTypeInternal _S_Connected_default_instance_;
PROTOBUF_CONSTEXPR S_Disconnected::S_Disconnected(
    ::_pbi::ConstantInitialized) {}
struct S_DisconnectedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_DisconnectedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_DisconnectedDefaultTypeInternal() {}
  union {
    S_Disconnected _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_DisconnectedDefaultTypeInternal _S_Disconnected_default_instance_;
PROTOBUF_CONSTEXPR C_Login::C_Login(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.accountdbid_)*/0
  , /*decltype(_impl_.token_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_LoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_LoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_LoginDefaultTypeInternal() {}
  union {
    C_Login _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_LoginDefaultTypeInternal _C_Login_default_instance_;
PROTOBUF_CONSTEXPR S_Login::S_Login(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.loginok_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_LoginDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_LoginDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_LoginDefaultTypeInternal() {}
  union {
    S_Login _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_LoginDefaultTypeInternal _S_Login_default_instance_;
PROTOBUF_CONSTEXPR C_CreateRoom::C_CreateRoom(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nickname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_CreateRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_CreateRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_CreateRoomDefaultTypeInternal() {}
  union {
    C_CreateRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_CreateRoomDefaultTypeInternal _C_CreateRoom_default_instance_;
PROTOBUF_CONSTEXPR C_EnterRoom::C_EnterRoom(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nickname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.roomcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct C_EnterRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_EnterRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_EnterRoomDefaultTypeInternal() {}
  union {
    C_EnterRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_EnterRoomDefaultTypeInternal _C_EnterRoom_default_instance_;
PROTOBUF_CONSTEXPR S_EnterRoom::S_EnterRoom(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.info_)*/nullptr
  , /*decltype(_impl_.enterroomok_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_EnterRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EnterRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EnterRoomDefaultTypeInternal() {}
  union {
    S_EnterRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EnterRoomDefaultTypeInternal _S_EnterRoom_default_instance_;
PROTOBUF_CONSTEXPR S_RoomPlayerList::S_RoomPlayerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.gamesessions_)*/{}
  , /*decltype(_impl_.roominfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct S_RoomPlayerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_RoomPlayerListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_RoomPlayerListDefaultTypeInternal() {}
  union {
    S_RoomPlayerList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_RoomPlayerListDefaultTypeInternal _S_RoomPlayerList_default_instance_;
PROTOBUF_CONSTEXPR C_LeaveRoom::C_LeaveRoom(
    ::_pbi::ConstantInitialized) {}
struct C_LeaveRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_LeaveRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_LeaveRoomDefaultTypeInternal() {}
  union {
    C_LeaveRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_LeaveRoomDefaultTypeInternal _C_LeaveRoom_default_instance_;
PROTOBUF_CONSTEXPR S_LeaveRoom::S_LeaveRoom(
    ::_pbi::ConstantInitialized) {}
struct S_LeaveRoomDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_LeaveRoomDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_LeaveRoomDefaultTypeInternal() {}
  union {
    S_LeaveRoom _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_LeaveRoomDefaultTypeInternal _S_LeaveRoom_default_instance_;
PROTOBUF_CONSTEXPR C_StartGame::C_StartGame(
    ::_pbi::ConstantInitialized) {}
struct C_StartGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_StartGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_StartGameDefaultTypeInternal() {}
  union {
    C_StartGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_StartGameDefaultTypeInternal _C_StartGame_default_instance_;
PROTOBUF_CONSTEXPR S_StartGame::S_StartGame(
    ::_pbi::ConstantInitialized) {}
struct S_StartGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_StartGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_StartGameDefaultTypeInternal() {}
  union {
    S_StartGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_StartGameDefaultTypeInternal _S_StartGame_default_instance_;
PROTOBUF_CONSTEXPR C_EnterGame::C_EnterGame(
    ::_pbi::ConstantInitialized) {}
struct C_EnterGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR C_EnterGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~C_EnterGameDefaultTypeInternal() {}
  union {
    C_EnterGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 C_EnterGameDefaultTypeInternal _C_EnterGame_default_instance_;
PROTOBUF_CONSTEXPR S_EndGame::S_EndGame(
    ::_pbi::ConstantInitialized) {}
struct S_EndGameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR S_EndGameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~S_EndGameDefaultTypeInternal() {}
  union {
    S_EndGame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 S_EndGameDefaultTypeInternal _S_EndGame_default_instance_;
PROTOBUF_CONSTEXPR RoomInfo::RoomInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.roomcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.roomid_)*/0
  , /*decltype(_impl_.hostsessionid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RoomInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RoomInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RoomInfoDefaultTypeInternal() {}
  union {
    RoomInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
PROTOBUF_CONSTEXPR GameSessionInfo::GameSessionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nickname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sessionid_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GameSessionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameSessionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameSessionInfoDefaultTypeInternal() {}
  union {
    GameSessionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameSessionInfoDefaultTypeInternal _GameSessionInfo_default_instance_;
PROTOBUF_CONSTEXPR ObjectInfo::ObjectInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.posinfo_)*/nullptr
  , /*decltype(_impl_.statinfo_)*/nullptr
  , /*decltype(_impl_.objectid_)*/0
  , /*decltype(_impl_.isedge_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ObjectInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ObjectInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ObjectInfoDefaultTypeInternal() {}
  union {
    ObjectInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
PROTOBUF_CONSTEXPR PositionInfo::PositionInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.state_)*/0
  , /*decltype(_impl_.movedir_)*/0
  , /*decltype(_impl_.posx_)*/0
  , /*decltype(_impl_.posy_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PositionInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionInfoDefaultTypeInternal() {}
  union {
    PositionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
PROTOBUF_CONSTEXPR StatInfo::StatInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.speedlvl_)*/0
  , /*decltype(_impl_.power_)*/0
  , /*decltype(_impl_.availbubble_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatInfoDefaultTypeInternal() {}
  union {
    StatInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatInfoDefaultTypeInternal _StatInfo_default_instance_;
}  // namespace Protocol
static ::_pb::Metadata file_level_metadata_Protocol_2eproto[30];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Protocol_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_Protocol_2eproto = nullptr;

const uint32_t TableStruct_Protocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterGame, _impl_.player_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LeaveGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Spawn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Spawn, _impl_.objects_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Despawn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Despawn, _impl_.objectids_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Move, _impl_.posinfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _impl_.objectid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Move, _impl_.posinfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Skill, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeStat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeStat, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_ChangeStat, _impl_.statinfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Pop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Pop, _impl_.objectid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Trap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Trap, _impl_.playerid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Die, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Die, _impl_.playerid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Connected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Disconnected, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Login, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Login, _impl_.accountdbid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_Login, _impl_.token_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Login, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_Login, _impl_.loginok_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_CreateRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_CreateRoom, _impl_.nickname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EnterRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EnterRoom, _impl_.nickname_),
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EnterRoom, _impl_.roomcode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterRoom, _impl_.enterroomok_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EnterRoom, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RoomPlayerList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RoomPlayerList, _impl_.roominfo_),
  PROTOBUF_FIELD_OFFSET(::Protocol::S_RoomPlayerList, _impl_.gamesessions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_LeaveRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_LeaveRoom, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_StartGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_StartGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::C_EnterGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::S_EndGame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::RoomInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::RoomInfo, _impl_.roomid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::RoomInfo, _impl_.roomcode_),
  PROTOBUF_FIELD_OFFSET(::Protocol::RoomInfo, _impl_.hostsessionid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::GameSessionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::GameSessionInfo, _impl_.sessionid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::GameSessionInfo, _impl_.nickname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _impl_.objectid_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _impl_.posinfo_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _impl_.statinfo_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ObjectInfo, _impl_.isedge_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::PositionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::PositionInfo, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::Protocol::PositionInfo, _impl_.movedir_),
  PROTOBUF_FIELD_OFFSET(::Protocol::PositionInfo, _impl_.posx_),
  PROTOBUF_FIELD_OFFSET(::Protocol::PositionInfo, _impl_.posy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::StatInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::StatInfo, _impl_.speedlvl_),
  PROTOBUF_FIELD_OFFSET(::Protocol::StatInfo, _impl_.power_),
  PROTOBUF_FIELD_OFFSET(::Protocol::StatInfo, _impl_.availbubble_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Protocol::S_EnterGame)},
  { 7, -1, -1, sizeof(::Protocol::S_LeaveGame)},
  { 13, -1, -1, sizeof(::Protocol::S_Spawn)},
  { 20, -1, -1, sizeof(::Protocol::S_Despawn)},
  { 27, -1, -1, sizeof(::Protocol::C_Move)},
  { 34, -1, -1, sizeof(::Protocol::S_Move)},
  { 42, -1, -1, sizeof(::Protocol::C_Skill)},
  { 48, -1, -1, sizeof(::Protocol::S_ChangeStat)},
  { 56, -1, -1, sizeof(::Protocol::S_Pop)},
  { 63, -1, -1, sizeof(::Protocol::S_Trap)},
  { 70, -1, -1, sizeof(::Protocol::S_Die)},
  { 77, -1, -1, sizeof(::Protocol::S_Connected)},
  { 83, -1, -1, sizeof(::Protocol::S_Disconnected)},
  { 89, -1, -1, sizeof(::Protocol::C_Login)},
  { 97, -1, -1, sizeof(::Protocol::S_Login)},
  { 104, -1, -1, sizeof(::Protocol::C_CreateRoom)},
  { 111, -1, -1, sizeof(::Protocol::C_EnterRoom)},
  { 119, -1, -1, sizeof(::Protocol::S_EnterRoom)},
  { 127, -1, -1, sizeof(::Protocol::S_RoomPlayerList)},
  { 135, -1, -1, sizeof(::Protocol::C_LeaveRoom)},
  { 141, -1, -1, sizeof(::Protocol::S_LeaveRoom)},
  { 147, -1, -1, sizeof(::Protocol::C_StartGame)},
  { 153, -1, -1, sizeof(::Protocol::S_StartGame)},
  { 159, -1, -1, sizeof(::Protocol::C_EnterGame)},
  { 165, -1, -1, sizeof(::Protocol::S_EndGame)},
  { 171, -1, -1, sizeof(::Protocol::RoomInfo)},
  { 180, -1, -1, sizeof(::Protocol::GameSessionInfo)},
  { 188, -1, -1, sizeof(::Protocol::ObjectInfo)},
  { 199, -1, -1, sizeof(::Protocol::PositionInfo)},
  { 209, -1, -1, sizeof(::Protocol::StatInfo)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Protocol::_S_EnterGame_default_instance_._instance,
  &::Protocol::_S_LeaveGame_default_instance_._instance,
  &::Protocol::_S_Spawn_default_instance_._instance,
  &::Protocol::_S_Despawn_default_instance_._instance,
  &::Protocol::_C_Move_default_instance_._instance,
  &::Protocol::_S_Move_default_instance_._instance,
  &::Protocol::_C_Skill_default_instance_._instance,
  &::Protocol::_S_ChangeStat_default_instance_._instance,
  &::Protocol::_S_Pop_default_instance_._instance,
  &::Protocol::_S_Trap_default_instance_._instance,
  &::Protocol::_S_Die_default_instance_._instance,
  &::Protocol::_S_Connected_default_instance_._instance,
  &::Protocol::_S_Disconnected_default_instance_._instance,
  &::Protocol::_C_Login_default_instance_._instance,
  &::Protocol::_S_Login_default_instance_._instance,
  &::Protocol::_C_CreateRoom_default_instance_._instance,
  &::Protocol::_C_EnterRoom_default_instance_._instance,
  &::Protocol::_S_EnterRoom_default_instance_._instance,
  &::Protocol::_S_RoomPlayerList_default_instance_._instance,
  &::Protocol::_C_LeaveRoom_default_instance_._instance,
  &::Protocol::_S_LeaveRoom_default_instance_._instance,
  &::Protocol::_C_StartGame_default_instance_._instance,
  &::Protocol::_S_StartGame_default_instance_._instance,
  &::Protocol::_C_EnterGame_default_instance_._instance,
  &::Protocol::_S_EndGame_default_instance_._instance,
  &::Protocol::_RoomInfo_default_instance_._instance,
  &::Protocol::_GameSessionInfo_default_instance_._instance,
  &::Protocol::_ObjectInfo_default_instance_._instance,
  &::Protocol::_PositionInfo_default_instance_._instance,
  &::Protocol::_StatInfo_default_instance_._instance,
};

const char descriptor_table_protodef_Protocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016Protocol.proto\022\010Protocol\"3\n\013S_EnterGam"
  "e\022$\n\006player\030\001 \001(\0132\024.Protocol.ObjectInfo\""
  "\r\n\013S_LeaveGame\"0\n\007S_Spawn\022%\n\007objects\030\001 \003"
  "(\0132\024.Protocol.ObjectInfo\"\036\n\tS_Despawn\022\021\n"
  "\tobjectIds\030\001 \003(\005\"1\n\006C_Move\022\'\n\007posInfo\030\001 "
  "\001(\0132\026.Protocol.PositionInfo\"C\n\006S_Move\022\020\n"
  "\010objectId\030\001 \001(\005\022\'\n\007posInfo\030\002 \001(\0132\026.Proto"
  "col.PositionInfo\"\t\n\007C_Skill\"F\n\014S_ChangeS"
  "tat\022\020\n\010playerId\030\001 \001(\005\022$\n\010statInfo\030\002 \001(\0132"
  "\022.Protocol.StatInfo\"\031\n\005S_Pop\022\020\n\010objectId"
  "\030\001 \001(\005\"\032\n\006S_Trap\022\020\n\010playerId\030\001 \001(\005\"\031\n\005S_"
  "Die\022\020\n\010playerId\030\001 \001(\005\"\r\n\013S_Connected\"\020\n\016"
  "S_Disconnected\"-\n\007C_Login\022\023\n\013accountDbId"
  "\030\001 \001(\005\022\r\n\005token\030\002 \001(\005\"\032\n\007S_Login\022\017\n\007logi"
  "nOk\030\001 \001(\010\" \n\014C_CreateRoom\022\020\n\010nickname\030\001 "
  "\001(\t\"1\n\013C_EnterRoom\022\020\n\010nickname\030\001 \001(\t\022\020\n\010"
  "roomCode\030\002 \001(\t\"K\n\013S_EnterRoom\022\023\n\013enterRo"
  "omOk\030\001 \001(\010\022\'\n\004info\030\002 \001(\0132\031.Protocol.Game"
  "SessionInfo\"i\n\020S_RoomPlayerList\022$\n\010roomI"
  "nfo\030\001 \001(\0132\022.Protocol.RoomInfo\022/\n\014gameSes"
  "sions\030\002 \003(\0132\031.Protocol.GameSessionInfo\"\r"
  "\n\013C_LeaveRoom\"\r\n\013S_LeaveRoom\"\r\n\013C_StartG"
  "ame\"\r\n\013S_StartGame\"\r\n\013C_EnterGame\"\013\n\tS_E"
  "ndGame\"C\n\010RoomInfo\022\016\n\006roomId\030\001 \001(\005\022\020\n\010ro"
  "omCode\030\002 \001(\t\022\025\n\rhostSessionId\030\003 \001(\005\"6\n\017G"
  "ameSessionInfo\022\021\n\tsessionId\030\001 \001(\005\022\020\n\010nic"
  "kname\030\002 \001(\t\"\213\001\n\nObjectInfo\022\020\n\010objectId\030\001"
  " \001(\005\022\014\n\004name\030\002 \001(\t\022\'\n\007posInfo\030\003 \001(\0132\026.Pr"
  "otocol.PositionInfo\022$\n\010statInfo\030\004 \001(\0132\022."
  "Protocol.StatInfo\022\016\n\006isEdge\030\005 \001(\010\"v\n\014Pos"
  "itionInfo\022&\n\005state\030\001 \001(\0162\027.Protocol.Crea"
  "tureState\022\"\n\007moveDir\030\002 \001(\0162\021.Protocol.Mo"
  "veDir\022\014\n\004posX\030\003 \001(\005\022\014\n\004posY\030\004 \001(\005\"@\n\010Sta"
  "tInfo\022\020\n\010speedLvl\030\001 \001(\005\022\r\n\005power\030\002 \001(\005\022\023"
  "\n\013availBubble\030\003 \001(\005*\231\003\n\005MsgId\022\020\n\014S_ENTER"
  "_GAME\020\000\022\020\n\014S_LEAVE_GAME\020\001\022\013\n\007S_SPAWN\020\002\022\r"
  "\n\tS_DESPAWN\020\003\022\n\n\006C_MOVE\020\004\022\n\n\006S_MOVE\020\005\022\013\n"
  "\007C_SKILL\020\006\022\021\n\rS_CHANGE_STAT\020\007\022\t\n\005S_POP\020\010"
  "\022\n\n\006S_TRAP\020\t\022\t\n\005S_DIE\020\n\022\017\n\013S_CONNECTED\020\013"
  "\022\022\n\016S_DISCONNECTED\020\014\022\013\n\007C_LOGIN\020\r\022\013\n\007S_L"
  "OGIN\020\016\022\021\n\rC_CREATE_ROOM\020\017\022\020\n\014C_ENTER_ROO"
  "M\020\020\022\020\n\014S_ENTER_ROOM\020\021\022\026\n\022S_ROOM_PLAYER_L"
  "IST\020\022\022\020\n\014C_LEAVE_ROOM\020\023\022\020\n\014S_LEAVE_ROOM\020"
  "\024\022\020\n\014C_START_GAME\020\025\022\020\n\014S_START_GAME\020\026\022\020\n"
  "\014C_ENTER_GAME\020\027\022\016\n\nS_END_GAME\020\030*B\n\rCreat"
  "ureState\022\010\n\004IDLE\020\000\022\n\n\006MOVING\020\001\022\010\n\004DEAD\020\002"
  "\022\007\n\003POP\020\003\022\010\n\004TRAP\020\004*0\n\007MoveDir\022\006\n\002UP\020\000\022\010"
  "\n\004DOWN\020\001\022\010\n\004LEFT\020\002\022\t\n\005RIGHT\020\003*Q\n\016GameObj"
  "ectType\022\010\n\004NONE\020\000\022\n\n\006PLAYER\020\001\022\t\n\005BLOCK\020\002"
  "\022\n\n\006BUBBLE\020\003\022\010\n\004WAVE\020\004\022\010\n\004ITEM\020\005B\033\252\002\030Goo"
  "gle.Protobuf.Protocolb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_Protocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Protocol_2eproto = {
    false, false, 2029, descriptor_table_protodef_Protocol_2eproto,
    "Protocol.proto",
    &descriptor_table_Protocol_2eproto_once, nullptr, 0, 30,
    schemas, file_default_instances, TableStruct_Protocol_2eproto::offsets,
    file_level_metadata_Protocol_2eproto, file_level_enum_descriptors_Protocol_2eproto,
    file_level_service_descriptors_Protocol_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Protocol_2eproto_getter() {
  return &descriptor_table_Protocol_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Protocol_2eproto(&descriptor_table_Protocol_2eproto);
namespace Protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgId_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Protocol_2eproto);
  return file_level_enum_descriptors_Protocol_2eproto[0];
}
bool MsgId_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreatureState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Protocol_2eproto);
  return file_level_enum_descriptors_Protocol_2eproto[1];
}
bool CreatureState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveDir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Protocol_2eproto);
  return file_level_enum_descriptors_Protocol_2eproto[2];
}
bool MoveDir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Protocol_2eproto);
  return file_level_enum_descriptors_Protocol_2eproto[3];
}
bool GameObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class S_EnterGame::_Internal {
 public:
  static const ::Protocol::ObjectInfo& player(const S_EnterGame* msg);
};

const ::Protocol::ObjectInfo&
S_EnterGame::_Internal::player(const S_EnterGame* msg) {
  return *msg->_impl_.player_;
}
S_EnterGame::S_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EnterGame)
}
S_EnterGame::S_EnterGame(const S_EnterGame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_EnterGame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_player()) {
    _this->_impl_.player_ = new ::Protocol::ObjectInfo(*from._impl_.player_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EnterGame)
}

inline void S_EnterGame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.player_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_EnterGame::~S_EnterGame() {
  // @@protoc_insertion_point(destructor:Protocol.S_EnterGame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_EnterGame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.player_;
}

void S_EnterGame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_EnterGame::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.player_ != nullptr) {
    delete _impl_.player_;
  }
  _impl_.player_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_EnterGame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.ObjectInfo player = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_player(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_EnterGame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_EnterGame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.ObjectInfo player = 1;
  if (this->_internal_has_player()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::player(this),
        _Internal::player(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_EnterGame)
  return target;
}

size_t S_EnterGame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_EnterGame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.ObjectInfo player = 1;
  if (this->_internal_has_player()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.player_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EnterGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_EnterGame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EnterGame::GetClassData() const { return &_class_data_; }


void S_EnterGame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_EnterGame*>(&to_msg);
  auto& from = static_cast<const S_EnterGame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_EnterGame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_player()) {
    _this->_internal_mutable_player()->::Protocol::ObjectInfo::MergeFrom(
        from._internal_player());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_EnterGame::CopyFrom(const S_EnterGame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_EnterGame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_EnterGame::IsInitialized() const {
  return true;
}

void S_EnterGame::InternalSwap(S_EnterGame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.player_, other->_impl_.player_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_EnterGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[0]);
}

// ===================================================================

class S_LeaveGame::_Internal {
 public:
};

S_LeaveGame::S_LeaveGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_LeaveGame)
}
S_LeaveGame::S_LeaveGame(const S_LeaveGame& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_LeaveGame* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_LeaveGame)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_LeaveGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_LeaveGame::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_LeaveGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[1]);
}

// ===================================================================

class S_Spawn::_Internal {
 public:
};

S_Spawn::S_Spawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Spawn)
}
S_Spawn::S_Spawn(const S_Spawn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Spawn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){from._impl_.objects_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Spawn)
}

inline void S_Spawn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objects_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Spawn::~S_Spawn() {
  // @@protoc_insertion_point(destructor:Protocol.S_Spawn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Spawn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objects_.~RepeatedPtrField();
}

void S_Spawn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Spawn::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Spawn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objects_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Spawn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Protocol.ObjectInfo objects = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Spawn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Spawn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objects_size()); i < n; i++) {
    const auto& repfield = this->_internal_objects(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Spawn)
  return target;
}

size_t S_Spawn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Spawn)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.ObjectInfo objects = 1;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->_impl_.objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Spawn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Spawn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Spawn::GetClassData() const { return &_class_data_; }


void S_Spawn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Spawn*>(&to_msg);
  auto& from = static_cast<const S_Spawn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Spawn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objects_.MergeFrom(from._impl_.objects_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Spawn::CopyFrom(const S_Spawn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Spawn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Spawn::IsInitialized() const {
  return true;
}

void S_Spawn::InternalSwap(S_Spawn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objects_.InternalSwap(&other->_impl_.objects_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Spawn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[2]);
}

// ===================================================================

class S_Despawn::_Internal {
 public:
};

S_Despawn::S_Despawn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Despawn)
}
S_Despawn::S_Despawn(const S_Despawn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Despawn* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectids_){from._impl_.objectids_}
    , /*decltype(_impl_._objectids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Despawn)
}

inline void S_Despawn::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectids_){arena}
    , /*decltype(_impl_._objectids_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Despawn::~S_Despawn() {
  // @@protoc_insertion_point(destructor:Protocol.S_Despawn)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Despawn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objectids_.~RepeatedField();
}

void S_Despawn::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Despawn::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Despawn)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objectids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Despawn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 objectIds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_objectids(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_objectids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Despawn::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Despawn)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 objectIds = 1;
  {
    int byte_size = _impl_._objectids_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_objectids(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Despawn)
  return target;
}

size_t S_Despawn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Despawn)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 objectIds = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.objectids_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._objectids_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Despawn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Despawn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Despawn::GetClassData() const { return &_class_data_; }


void S_Despawn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Despawn*>(&to_msg);
  auto& from = static_cast<const S_Despawn&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Despawn)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objectids_.MergeFrom(from._impl_.objectids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Despawn::CopyFrom(const S_Despawn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Despawn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Despawn::IsInitialized() const {
  return true;
}

void S_Despawn::InternalSwap(S_Despawn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objectids_.InternalSwap(&other->_impl_.objectids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Despawn::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[3]);
}

// ===================================================================

class C_Move::_Internal {
 public:
  static const ::Protocol::PositionInfo& posinfo(const C_Move* msg);
};

const ::Protocol::PositionInfo&
C_Move::_Internal::posinfo(const C_Move* msg) {
  return *msg->_impl_.posinfo_;
}
C_Move::C_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Move)
}
C_Move::C_Move(const C_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.posinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_posinfo()) {
    _this->_impl_.posinfo_ = new ::Protocol::PositionInfo(*from._impl_.posinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Move)
}

inline void C_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.posinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Move::~C_Move() {
  // @@protoc_insertion_point(destructor:Protocol.C_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.posinfo_;
}

void C_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.PositionInfo posInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_posinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.PositionInfo posInfo = 1;
  if (this->_internal_has_posinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::posinfo(this),
        _Internal::posinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Move)
  return target;
}

size_t C_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.PositionInfo posInfo = 1;
  if (this->_internal_has_posinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.posinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Move::GetClassData() const { return &_class_data_; }


void C_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Move*>(&to_msg);
  auto& from = static_cast<const C_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_posinfo()) {
    _this->_internal_mutable_posinfo()->::Protocol::PositionInfo::MergeFrom(
        from._internal_posinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Move::CopyFrom(const C_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Move::IsInitialized() const {
  return true;
}

void C_Move::InternalSwap(C_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.posinfo_, other->_impl_.posinfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[4]);
}

// ===================================================================

class S_Move::_Internal {
 public:
  static const ::Protocol::PositionInfo& posinfo(const S_Move* msg);
};

const ::Protocol::PositionInfo&
S_Move::_Internal::posinfo(const S_Move* msg) {
  return *msg->_impl_.posinfo_;
}
S_Move::S_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Move)
}
S_Move::S_Move(const S_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.posinfo_){nullptr}
    , decltype(_impl_.objectid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_posinfo()) {
    _this->_impl_.posinfo_ = new ::Protocol::PositionInfo(*from._impl_.posinfo_);
  }
  _this->_impl_.objectid_ = from._impl_.objectid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Move)
}

inline void S_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.posinfo_){nullptr}
    , decltype(_impl_.objectid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Move::~S_Move() {
  // @@protoc_insertion_point(destructor:Protocol.S_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.posinfo_;
}

void S_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
  _impl_.objectid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.PositionInfo posInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_posinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_objectid(), target);
  }

  // .Protocol.PositionInfo posInfo = 2;
  if (this->_internal_has_posinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::posinfo(this),
        _Internal::posinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Move)
  return target;
}

size_t S_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.PositionInfo posInfo = 2;
  if (this->_internal_has_posinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.posinfo_);
  }

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_objectid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Move::GetClassData() const { return &_class_data_; }


void S_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Move*>(&to_msg);
  auto& from = static_cast<const S_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_posinfo()) {
    _this->_internal_mutable_posinfo()->::Protocol::PositionInfo::MergeFrom(
        from._internal_posinfo());
  }
  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Move::CopyFrom(const S_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Move::IsInitialized() const {
  return true;
}

void S_Move::InternalSwap(S_Move* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_Move, _impl_.objectid_)
      + sizeof(S_Move::_impl_.objectid_)
      - PROTOBUF_FIELD_OFFSET(S_Move, _impl_.posinfo_)>(
          reinterpret_cast<char*>(&_impl_.posinfo_),
          reinterpret_cast<char*>(&other->_impl_.posinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[5]);
}

// ===================================================================

class C_Skill::_Internal {
 public:
};

C_Skill::C_Skill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Skill)
}
C_Skill::C_Skill(const C_Skill& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  C_Skill* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Skill)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Skill::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Skill::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata C_Skill::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[6]);
}

// ===================================================================

class S_ChangeStat::_Internal {
 public:
  static const ::Protocol::StatInfo& statinfo(const S_ChangeStat* msg);
};

const ::Protocol::StatInfo&
S_ChangeStat::_Internal::statinfo(const S_ChangeStat* msg) {
  return *msg->_impl_.statinfo_;
}
S_ChangeStat::S_ChangeStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_ChangeStat)
}
S_ChangeStat::S_ChangeStat(const S_ChangeStat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_ChangeStat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.statinfo_){nullptr}
    , decltype(_impl_.playerid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_statinfo()) {
    _this->_impl_.statinfo_ = new ::Protocol::StatInfo(*from._impl_.statinfo_);
  }
  _this->_impl_.playerid_ = from._impl_.playerid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_ChangeStat)
}

inline void S_ChangeStat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.statinfo_){nullptr}
    , decltype(_impl_.playerid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_ChangeStat::~S_ChangeStat() {
  // @@protoc_insertion_point(destructor:Protocol.S_ChangeStat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_ChangeStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.statinfo_;
}

void S_ChangeStat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_ChangeStat::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_ChangeStat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.statinfo_ != nullptr) {
    delete _impl_.statinfo_;
  }
  _impl_.statinfo_ = nullptr;
  _impl_.playerid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_ChangeStat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.StatInfo statInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_statinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_ChangeStat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_ChangeStat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playerid(), target);
  }

  // .Protocol.StatInfo statInfo = 2;
  if (this->_internal_has_statinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::statinfo(this),
        _Internal::statinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_ChangeStat)
  return target;
}

size_t S_ChangeStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_ChangeStat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.StatInfo statInfo = 2;
  if (this->_internal_has_statinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.statinfo_);
  }

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_ChangeStat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_ChangeStat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_ChangeStat::GetClassData() const { return &_class_data_; }


void S_ChangeStat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_ChangeStat*>(&to_msg);
  auto& from = static_cast<const S_ChangeStat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_ChangeStat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_statinfo()) {
    _this->_internal_mutable_statinfo()->::Protocol::StatInfo::MergeFrom(
        from._internal_statinfo());
  }
  if (from._internal_playerid() != 0) {
    _this->_internal_set_playerid(from._internal_playerid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_ChangeStat::CopyFrom(const S_ChangeStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_ChangeStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_ChangeStat::IsInitialized() const {
  return true;
}

void S_ChangeStat::InternalSwap(S_ChangeStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_ChangeStat, _impl_.playerid_)
      + sizeof(S_ChangeStat::_impl_.playerid_)
      - PROTOBUF_FIELD_OFFSET(S_ChangeStat, _impl_.statinfo_)>(
          reinterpret_cast<char*>(&_impl_.statinfo_),
          reinterpret_cast<char*>(&other->_impl_.statinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_ChangeStat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[7]);
}

// ===================================================================

class S_Pop::_Internal {
 public:
};

S_Pop::S_Pop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Pop)
}
S_Pop::S_Pop(const S_Pop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Pop* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.objectid_ = from._impl_.objectid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Pop)
}

inline void S_Pop::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objectid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Pop::~S_Pop() {
  // @@protoc_insertion_point(destructor:Protocol.S_Pop)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Pop::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Pop::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Pop::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Pop)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objectid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Pop::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Pop::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Pop)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_objectid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Pop)
  return target;
}

size_t S_Pop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Pop)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_objectid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Pop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Pop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Pop::GetClassData() const { return &_class_data_; }


void S_Pop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Pop*>(&to_msg);
  auto& from = static_cast<const S_Pop&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Pop)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Pop::CopyFrom(const S_Pop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Pop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Pop::IsInitialized() const {
  return true;
}

void S_Pop::InternalSwap(S_Pop* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.objectid_, other->_impl_.objectid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Pop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[8]);
}

// ===================================================================

class S_Trap::_Internal {
 public:
};

S_Trap::S_Trap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Trap)
}
S_Trap::S_Trap(const S_Trap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Trap* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.playerid_ = from._impl_.playerid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Trap)
}

inline void S_Trap::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Trap::~S_Trap() {
  // @@protoc_insertion_point(destructor:Protocol.S_Trap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Trap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Trap::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Trap::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Trap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.playerid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Trap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Trap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Trap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Trap)
  return target;
}

size_t S_Trap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Trap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Trap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Trap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Trap::GetClassData() const { return &_class_data_; }


void S_Trap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Trap*>(&to_msg);
  auto& from = static_cast<const S_Trap&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Trap)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_playerid() != 0) {
    _this->_internal_set_playerid(from._internal_playerid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Trap::CopyFrom(const S_Trap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Trap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Trap::IsInitialized() const {
  return true;
}

void S_Trap::InternalSwap(S_Trap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.playerid_, other->_impl_.playerid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Trap::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[9]);
}

// ===================================================================

class S_Die::_Internal {
 public:
};

S_Die::S_Die(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Die)
}
S_Die::S_Die(const S_Die& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Die* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.playerid_ = from._impl_.playerid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Die)
}

inline void S_Die::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Die::~S_Die() {
  // @@protoc_insertion_point(destructor:Protocol.S_Die)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Die::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Die::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Die::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Die)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.playerid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Die::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 playerId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Die::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Die)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_playerid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Die)
  return target;
}

size_t S_Die::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Die)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 playerId = 1;
  if (this->_internal_playerid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Die::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Die::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Die::GetClassData() const { return &_class_data_; }


void S_Die::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Die*>(&to_msg);
  auto& from = static_cast<const S_Die&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Die)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_playerid() != 0) {
    _this->_internal_set_playerid(from._internal_playerid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Die::CopyFrom(const S_Die& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Die)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Die::IsInitialized() const {
  return true;
}

void S_Die::InternalSwap(S_Die* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.playerid_, other->_impl_.playerid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Die::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[10]);
}

// ===================================================================

class S_Connected::_Internal {
 public:
};

S_Connected::S_Connected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Connected)
}
S_Connected::S_Connected(const S_Connected& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_Connected* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Connected)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Connected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Connected::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_Connected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[11]);
}

// ===================================================================

class S_Disconnected::_Internal {
 public:
};

S_Disconnected::S_Disconnected(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Disconnected)
}
S_Disconnected::S_Disconnected(const S_Disconnected& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_Disconnected* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Disconnected)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Disconnected::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Disconnected::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_Disconnected::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[12]);
}

// ===================================================================

class C_Login::_Internal {
 public:
};

C_Login::C_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_Login)
}
C_Login::C_Login(const C_Login& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_Login* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.accountdbid_){}
    , decltype(_impl_.token_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.accountdbid_, &from._impl_.accountdbid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.token_) -
    reinterpret_cast<char*>(&_impl_.accountdbid_)) + sizeof(_impl_.token_));
  // @@protoc_insertion_point(copy_constructor:Protocol.C_Login)
}

inline void C_Login::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.accountdbid_){0}
    , decltype(_impl_.token_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

C_Login::~C_Login() {
  // @@protoc_insertion_point(destructor:Protocol.C_Login)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_Login::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void C_Login::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_Login::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_Login)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.accountdbid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.token_) -
      reinterpret_cast<char*>(&_impl_.accountdbid_)) + sizeof(_impl_.token_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_Login::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 accountDbId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.accountdbid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_Login::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_Login)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 accountDbId = 1;
  if (this->_internal_accountdbid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_accountdbid(), target);
  }

  // int32 token = 2;
  if (this->_internal_token() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_Login)
  return target;
}

size_t C_Login::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_Login)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 accountDbId = 1;
  if (this->_internal_accountdbid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_accountdbid());
  }

  // int32 token = 2;
  if (this->_internal_token() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_Login::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_Login::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_Login::GetClassData() const { return &_class_data_; }


void C_Login::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_Login*>(&to_msg);
  auto& from = static_cast<const C_Login&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_Login)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_accountdbid() != 0) {
    _this->_internal_set_accountdbid(from._internal_accountdbid());
  }
  if (from._internal_token() != 0) {
    _this->_internal_set_token(from._internal_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_Login::CopyFrom(const C_Login& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_Login)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_Login::IsInitialized() const {
  return true;
}

void C_Login::InternalSwap(C_Login* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(C_Login, _impl_.token_)
      + sizeof(C_Login::_impl_.token_)
      - PROTOBUF_FIELD_OFFSET(C_Login, _impl_.accountdbid_)>(
          reinterpret_cast<char*>(&_impl_.accountdbid_),
          reinterpret_cast<char*>(&other->_impl_.accountdbid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata C_Login::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[13]);
}

// ===================================================================

class S_Login::_Internal {
 public:
};

S_Login::S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_Login)
}
S_Login::S_Login(const S_Login& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_Login* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.loginok_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.loginok_ = from._impl_.loginok_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_Login)
}

inline void S_Login::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.loginok_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_Login::~S_Login() {
  // @@protoc_insertion_point(destructor:Protocol.S_Login)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_Login::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void S_Login::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_Login::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_Login)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.loginok_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_Login::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool loginOk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.loginok_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_Login::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_Login)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool loginOk = 1;
  if (this->_internal_loginok() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_loginok(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_Login)
  return target;
}

size_t S_Login::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_Login)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool loginOk = 1;
  if (this->_internal_loginok() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_Login::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_Login::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_Login::GetClassData() const { return &_class_data_; }


void S_Login::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_Login*>(&to_msg);
  auto& from = static_cast<const S_Login&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_Login)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_loginok() != 0) {
    _this->_internal_set_loginok(from._internal_loginok());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_Login::CopyFrom(const S_Login& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_Login)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_Login::IsInitialized() const {
  return true;
}

void S_Login::InternalSwap(S_Login* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.loginok_, other->_impl_.loginok_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_Login::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[14]);
}

// ===================================================================

class C_CreateRoom::_Internal {
 public:
};

C_CreateRoom::C_CreateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_CreateRoom)
}
C_CreateRoom::C_CreateRoom(const C_CreateRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_CreateRoom* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nickname().empty()) {
    _this->_impl_.nickname_.Set(from._internal_nickname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_CreateRoom)
}

inline void C_CreateRoom::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

C_CreateRoom::~C_CreateRoom() {
  // @@protoc_insertion_point(destructor:Protocol.C_CreateRoom)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_CreateRoom::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nickname_.Destroy();
}

void C_CreateRoom::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_CreateRoom::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_CreateRoom)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nickname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_CreateRoom::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string nickname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nickname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.C_CreateRoom.nickname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_CreateRoom::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_CreateRoom)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nickname().data(), static_cast<int>(this->_internal_nickname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.C_CreateRoom.nickname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nickname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_CreateRoom)
  return target;
}

size_t C_CreateRoom::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_CreateRoom)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nickname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_CreateRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_CreateRoom::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_CreateRoom::GetClassData() const { return &_class_data_; }


void C_CreateRoom::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_CreateRoom*>(&to_msg);
  auto& from = static_cast<const C_CreateRoom&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_CreateRoom)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nickname().empty()) {
    _this->_internal_set_nickname(from._internal_nickname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_CreateRoom::CopyFrom(const C_CreateRoom& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_CreateRoom)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_CreateRoom::IsInitialized() const {
  return true;
}

void C_CreateRoom::InternalSwap(C_CreateRoom* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nickname_, lhs_arena,
      &other->_impl_.nickname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata C_CreateRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[15]);
}

// ===================================================================

class C_EnterRoom::_Internal {
 public:
};

C_EnterRoom::C_EnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.C_EnterRoom)
}
C_EnterRoom::C_EnterRoom(const C_EnterRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  C_EnterRoom* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , decltype(_impl_.roomcode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nickname().empty()) {
    _this->_impl_.nickname_.Set(from._internal_nickname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.roomcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_roomcode().empty()) {
    _this->_impl_.roomcode_.Set(from._internal_roomcode(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.C_EnterRoom)
}

inline void C_EnterRoom::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , decltype(_impl_.roomcode_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.roomcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

C_EnterRoom::~C_EnterRoom() {
  // @@protoc_insertion_point(destructor:Protocol.C_EnterRoom)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void C_EnterRoom::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nickname_.Destroy();
  _impl_.roomcode_.Destroy();
}

void C_EnterRoom::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void C_EnterRoom::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.C_EnterRoom)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nickname_.ClearToEmpty();
  _impl_.roomcode_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* C_EnterRoom::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string nickname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nickname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.C_EnterRoom.nickname"));
        } else
          goto handle_unusual;
        continue;
      // string roomCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_roomcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.C_EnterRoom.roomCode"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* C_EnterRoom::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.C_EnterRoom)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nickname().data(), static_cast<int>(this->_internal_nickname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.C_EnterRoom.nickname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nickname(), target);
  }

  // string roomCode = 2;
  if (!this->_internal_roomcode().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_roomcode().data(), static_cast<int>(this->_internal_roomcode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.C_EnterRoom.roomCode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_roomcode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.C_EnterRoom)
  return target;
}

size_t C_EnterRoom::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.C_EnterRoom)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nickname());
  }

  // string roomCode = 2;
  if (!this->_internal_roomcode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_roomcode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_EnterRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    C_EnterRoom::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_EnterRoom::GetClassData() const { return &_class_data_; }


void C_EnterRoom::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<C_EnterRoom*>(&to_msg);
  auto& from = static_cast<const C_EnterRoom&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.C_EnterRoom)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nickname().empty()) {
    _this->_internal_set_nickname(from._internal_nickname());
  }
  if (!from._internal_roomcode().empty()) {
    _this->_internal_set_roomcode(from._internal_roomcode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void C_EnterRoom::CopyFrom(const C_EnterRoom& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.C_EnterRoom)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool C_EnterRoom::IsInitialized() const {
  return true;
}

void C_EnterRoom::InternalSwap(C_EnterRoom* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nickname_, lhs_arena,
      &other->_impl_.nickname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.roomcode_, lhs_arena,
      &other->_impl_.roomcode_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata C_EnterRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[16]);
}

// ===================================================================

class S_EnterRoom::_Internal {
 public:
  static const ::Protocol::GameSessionInfo& info(const S_EnterRoom* msg);
};

const ::Protocol::GameSessionInfo&
S_EnterRoom::_Internal::info(const S_EnterRoom* msg) {
  return *msg->_impl_.info_;
}
S_EnterRoom::S_EnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EnterRoom)
}
S_EnterRoom::S_EnterRoom(const S_EnterRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_EnterRoom* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.enterroomok_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    _this->_impl_.info_ = new ::Protocol::GameSessionInfo(*from._impl_.info_);
  }
  _this->_impl_.enterroomok_ = from._impl_.enterroomok_;
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EnterRoom)
}

inline void S_EnterRoom::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.info_){nullptr}
    , decltype(_impl_.enterroomok_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_EnterRoom::~S_EnterRoom() {
  // @@protoc_insertion_point(destructor:Protocol.S_EnterRoom)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_EnterRoom::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.info_;
}

void S_EnterRoom::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_EnterRoom::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_EnterRoom)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.info_ != nullptr) {
    delete _impl_.info_;
  }
  _impl_.info_ = nullptr;
  _impl_.enterroomok_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_EnterRoom::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool enterRoomOk = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.enterroomok_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.GameSessionInfo info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_EnterRoom::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_EnterRoom)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool enterRoomOk = 1;
  if (this->_internal_enterroomok() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_enterroomok(), target);
  }

  // .Protocol.GameSessionInfo info = 2;
  if (this->_internal_has_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::info(this),
        _Internal::info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_EnterRoom)
  return target;
}

size_t S_EnterRoom::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_EnterRoom)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.GameSessionInfo info = 2;
  if (this->_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.info_);
  }

  // bool enterRoomOk = 1;
  if (this->_internal_enterroomok() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EnterRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_EnterRoom::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EnterRoom::GetClassData() const { return &_class_data_; }


void S_EnterRoom::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_EnterRoom*>(&to_msg);
  auto& from = static_cast<const S_EnterRoom&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_EnterRoom)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _this->_internal_mutable_info()->::Protocol::GameSessionInfo::MergeFrom(
        from._internal_info());
  }
  if (from._internal_enterroomok() != 0) {
    _this->_internal_set_enterroomok(from._internal_enterroomok());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_EnterRoom::CopyFrom(const S_EnterRoom& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_EnterRoom)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_EnterRoom::IsInitialized() const {
  return true;
}

void S_EnterRoom::InternalSwap(S_EnterRoom* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(S_EnterRoom, _impl_.enterroomok_)
      + sizeof(S_EnterRoom::_impl_.enterroomok_)
      - PROTOBUF_FIELD_OFFSET(S_EnterRoom, _impl_.info_)>(
          reinterpret_cast<char*>(&_impl_.info_),
          reinterpret_cast<char*>(&other->_impl_.info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata S_EnterRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[17]);
}

// ===================================================================

class S_RoomPlayerList::_Internal {
 public:
  static const ::Protocol::RoomInfo& roominfo(const S_RoomPlayerList* msg);
};

const ::Protocol::RoomInfo&
S_RoomPlayerList::_Internal::roominfo(const S_RoomPlayerList* msg) {
  return *msg->_impl_.roominfo_;
}
S_RoomPlayerList::S_RoomPlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.S_RoomPlayerList)
}
S_RoomPlayerList::S_RoomPlayerList(const S_RoomPlayerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  S_RoomPlayerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.gamesessions_){from._impl_.gamesessions_}
    , decltype(_impl_.roominfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_roominfo()) {
    _this->_impl_.roominfo_ = new ::Protocol::RoomInfo(*from._impl_.roominfo_);
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.S_RoomPlayerList)
}

inline void S_RoomPlayerList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.gamesessions_){arena}
    , decltype(_impl_.roominfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

S_RoomPlayerList::~S_RoomPlayerList() {
  // @@protoc_insertion_point(destructor:Protocol.S_RoomPlayerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void S_RoomPlayerList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gamesessions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.roominfo_;
}

void S_RoomPlayerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void S_RoomPlayerList::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.S_RoomPlayerList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gamesessions_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.roominfo_ != nullptr) {
    delete _impl_.roominfo_;
  }
  _impl_.roominfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* S_RoomPlayerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.RoomInfo roomInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_roominfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Protocol.GameSessionInfo gameSessions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gamesessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* S_RoomPlayerList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.S_RoomPlayerList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.RoomInfo roomInfo = 1;
  if (this->_internal_has_roominfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::roominfo(this),
        _Internal::roominfo(this).GetCachedSize(), target, stream);
  }

  // repeated .Protocol.GameSessionInfo gameSessions = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gamesessions_size()); i < n; i++) {
    const auto& repfield = this->_internal_gamesessions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.S_RoomPlayerList)
  return target;
}

size_t S_RoomPlayerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.S_RoomPlayerList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Protocol.GameSessionInfo gameSessions = 2;
  total_size += 1UL * this->_internal_gamesessions_size();
  for (const auto& msg : this->_impl_.gamesessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Protocol.RoomInfo roomInfo = 1;
  if (this->_internal_has_roominfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.roominfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_RoomPlayerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    S_RoomPlayerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_RoomPlayerList::GetClassData() const { return &_class_data_; }


void S_RoomPlayerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<S_RoomPlayerList*>(&to_msg);
  auto& from = static_cast<const S_RoomPlayerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.S_RoomPlayerList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gamesessions_.MergeFrom(from._impl_.gamesessions_);
  if (from._internal_has_roominfo()) {
    _this->_internal_mutable_roominfo()->::Protocol::RoomInfo::MergeFrom(
        from._internal_roominfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void S_RoomPlayerList::CopyFrom(const S_RoomPlayerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.S_RoomPlayerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool S_RoomPlayerList::IsInitialized() const {
  return true;
}

void S_RoomPlayerList::InternalSwap(S_RoomPlayerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.gamesessions_.InternalSwap(&other->_impl_.gamesessions_);
  swap(_impl_.roominfo_, other->_impl_.roominfo_);
}

::PROTOBUF_NAMESPACE_ID::Metadata S_RoomPlayerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[18]);
}

// ===================================================================

class C_LeaveRoom::_Internal {
 public:
};

C_LeaveRoom::C_LeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.C_LeaveRoom)
}
C_LeaveRoom::C_LeaveRoom(const C_LeaveRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  C_LeaveRoom* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.C_LeaveRoom)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_LeaveRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_LeaveRoom::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata C_LeaveRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[19]);
}

// ===================================================================

class S_LeaveRoom::_Internal {
 public:
};

S_LeaveRoom::S_LeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_LeaveRoom)
}
S_LeaveRoom::S_LeaveRoom(const S_LeaveRoom& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_LeaveRoom* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_LeaveRoom)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_LeaveRoom::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_LeaveRoom::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_LeaveRoom::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[20]);
}

// ===================================================================

class C_StartGame::_Internal {
 public:
};

C_StartGame::C_StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.C_StartGame)
}
C_StartGame::C_StartGame(const C_StartGame& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  C_StartGame* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.C_StartGame)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_StartGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_StartGame::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata C_StartGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[21]);
}

// ===================================================================

class S_StartGame::_Internal {
 public:
};

S_StartGame::S_StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_StartGame)
}
S_StartGame::S_StartGame(const S_StartGame& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_StartGame* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_StartGame)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_StartGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_StartGame::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_StartGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[22]);
}

// ===================================================================

class C_EnterGame::_Internal {
 public:
};

C_EnterGame::C_EnterGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.C_EnterGame)
}
C_EnterGame::C_EnterGame(const C_EnterGame& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  C_EnterGame* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.C_EnterGame)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData C_EnterGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*C_EnterGame::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata C_EnterGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[23]);
}

// ===================================================================

class S_EndGame::_Internal {
 public:
};

S_EndGame::S_EndGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:Protocol.S_EndGame)
}
S_EndGame::S_EndGame(const S_EndGame& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  S_EndGame* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Protocol.S_EndGame)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData S_EndGame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*S_EndGame::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata S_EndGame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[24]);
}

// ===================================================================

class RoomInfo::_Internal {
 public:
};

RoomInfo::RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.RoomInfo)
}
RoomInfo::RoomInfo(const RoomInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RoomInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.roomcode_){}
    , decltype(_impl_.roomid_){}
    , decltype(_impl_.hostsessionid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.roomcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_roomcode().empty()) {
    _this->_impl_.roomcode_.Set(from._internal_roomcode(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.roomid_, &from._impl_.roomid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hostsessionid_) -
    reinterpret_cast<char*>(&_impl_.roomid_)) + sizeof(_impl_.hostsessionid_));
  // @@protoc_insertion_point(copy_constructor:Protocol.RoomInfo)
}

inline void RoomInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.roomcode_){}
    , decltype(_impl_.roomid_){0}
    , decltype(_impl_.hostsessionid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.roomcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.roomcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RoomInfo::~RoomInfo() {
  // @@protoc_insertion_point(destructor:Protocol.RoomInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RoomInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.roomcode_.Destroy();
}

void RoomInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RoomInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.RoomInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.roomcode_.ClearToEmpty();
  ::memset(&_impl_.roomid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.hostsessionid_) -
      reinterpret_cast<char*>(&_impl_.roomid_)) + sizeof(_impl_.hostsessionid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RoomInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 roomId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.roomid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string roomCode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_roomcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.RoomInfo.roomCode"));
        } else
          goto handle_unusual;
        continue;
      // int32 hostSessionId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.hostsessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RoomInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.RoomInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 roomId = 1;
  if (this->_internal_roomid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_roomid(), target);
  }

  // string roomCode = 2;
  if (!this->_internal_roomcode().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_roomcode().data(), static_cast<int>(this->_internal_roomcode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.RoomInfo.roomCode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_roomcode(), target);
  }

  // int32 hostSessionId = 3;
  if (this->_internal_hostsessionid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_hostsessionid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.RoomInfo)
  return target;
}

size_t RoomInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.RoomInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string roomCode = 2;
  if (!this->_internal_roomcode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_roomcode());
  }

  // int32 roomId = 1;
  if (this->_internal_roomid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_roomid());
  }

  // int32 hostSessionId = 3;
  if (this->_internal_hostsessionid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hostsessionid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RoomInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RoomInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RoomInfo::GetClassData() const { return &_class_data_; }


void RoomInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RoomInfo*>(&to_msg);
  auto& from = static_cast<const RoomInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.RoomInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_roomcode().empty()) {
    _this->_internal_set_roomcode(from._internal_roomcode());
  }
  if (from._internal_roomid() != 0) {
    _this->_internal_set_roomid(from._internal_roomid());
  }
  if (from._internal_hostsessionid() != 0) {
    _this->_internal_set_hostsessionid(from._internal_hostsessionid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RoomInfo::CopyFrom(const RoomInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.RoomInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomInfo::IsInitialized() const {
  return true;
}

void RoomInfo::InternalSwap(RoomInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.roomcode_, lhs_arena,
      &other->_impl_.roomcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RoomInfo, _impl_.hostsessionid_)
      + sizeof(RoomInfo::_impl_.hostsessionid_)
      - PROTOBUF_FIELD_OFFSET(RoomInfo, _impl_.roomid_)>(
          reinterpret_cast<char*>(&_impl_.roomid_),
          reinterpret_cast<char*>(&other->_impl_.roomid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RoomInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[25]);
}

// ===================================================================

class GameSessionInfo::_Internal {
 public:
};

GameSessionInfo::GameSessionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.GameSessionInfo)
}
GameSessionInfo::GameSessionInfo(const GameSessionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameSessionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , decltype(_impl_.sessionid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nickname().empty()) {
    _this->_impl_.nickname_.Set(from._internal_nickname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.sessionid_ = from._impl_.sessionid_;
  // @@protoc_insertion_point(copy_constructor:Protocol.GameSessionInfo)
}

inline void GameSessionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nickname_){}
    , decltype(_impl_.sessionid_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameSessionInfo::~GameSessionInfo() {
  // @@protoc_insertion_point(destructor:Protocol.GameSessionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameSessionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nickname_.Destroy();
}

void GameSessionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameSessionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.GameSessionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nickname_.ClearToEmpty();
  _impl_.sessionid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameSessionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sessionId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string nickname = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_nickname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.GameSessionInfo.nickname"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameSessionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.GameSessionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sessionId = 1;
  if (this->_internal_sessionid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sessionid(), target);
  }

  // string nickname = 2;
  if (!this->_internal_nickname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nickname().data(), static_cast<int>(this->_internal_nickname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.GameSessionInfo.nickname");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_nickname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.GameSessionInfo)
  return target;
}

size_t GameSessionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.GameSessionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nickname = 2;
  if (!this->_internal_nickname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nickname());
  }

  // int32 sessionId = 1;
  if (this->_internal_sessionid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sessionid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameSessionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameSessionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameSessionInfo::GetClassData() const { return &_class_data_; }


void GameSessionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameSessionInfo*>(&to_msg);
  auto& from = static_cast<const GameSessionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.GameSessionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nickname().empty()) {
    _this->_internal_set_nickname(from._internal_nickname());
  }
  if (from._internal_sessionid() != 0) {
    _this->_internal_set_sessionid(from._internal_sessionid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameSessionInfo::CopyFrom(const GameSessionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.GameSessionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameSessionInfo::IsInitialized() const {
  return true;
}

void GameSessionInfo::InternalSwap(GameSessionInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nickname_, lhs_arena,
      &other->_impl_.nickname_, rhs_arena
  );
  swap(_impl_.sessionid_, other->_impl_.sessionid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GameSessionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[26]);
}

// ===================================================================

class ObjectInfo::_Internal {
 public:
  static const ::Protocol::PositionInfo& posinfo(const ObjectInfo* msg);
  static const ::Protocol::StatInfo& statinfo(const ObjectInfo* msg);
};

const ::Protocol::PositionInfo&
ObjectInfo::_Internal::posinfo(const ObjectInfo* msg) {
  return *msg->_impl_.posinfo_;
}
const ::Protocol::StatInfo&
ObjectInfo::_Internal::statinfo(const ObjectInfo* msg) {
  return *msg->_impl_.statinfo_;
}
ObjectInfo::ObjectInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.ObjectInfo)
}
ObjectInfo::ObjectInfo(const ObjectInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ObjectInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.posinfo_){nullptr}
    , decltype(_impl_.statinfo_){nullptr}
    , decltype(_impl_.objectid_){}
    , decltype(_impl_.isedge_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_posinfo()) {
    _this->_impl_.posinfo_ = new ::Protocol::PositionInfo(*from._impl_.posinfo_);
  }
  if (from._internal_has_statinfo()) {
    _this->_impl_.statinfo_ = new ::Protocol::StatInfo(*from._impl_.statinfo_);
  }
  ::memcpy(&_impl_.objectid_, &from._impl_.objectid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isedge_) -
    reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.isedge_));
  // @@protoc_insertion_point(copy_constructor:Protocol.ObjectInfo)
}

inline void ObjectInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.posinfo_){nullptr}
    , decltype(_impl_.statinfo_){nullptr}
    , decltype(_impl_.objectid_){0}
    , decltype(_impl_.isedge_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ObjectInfo::~ObjectInfo() {
  // @@protoc_insertion_point(destructor:Protocol.ObjectInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ObjectInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.posinfo_;
  if (this != internal_default_instance()) delete _impl_.statinfo_;
}

void ObjectInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ObjectInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.ObjectInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.posinfo_ != nullptr) {
    delete _impl_.posinfo_;
  }
  _impl_.posinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.statinfo_ != nullptr) {
    delete _impl_.statinfo_;
  }
  _impl_.statinfo_ = nullptr;
  ::memset(&_impl_.objectid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isedge_) -
      reinterpret_cast<char*>(&_impl_.objectid_)) + sizeof(_impl_.isedge_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ObjectInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 objectId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.objectid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.ObjectInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.PositionInfo posInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_posinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.StatInfo statInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_statinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isEdge = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.isedge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ObjectInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.ObjectInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_objectid(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.ObjectInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .Protocol.PositionInfo posInfo = 3;
  if (this->_internal_has_posinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::posinfo(this),
        _Internal::posinfo(this).GetCachedSize(), target, stream);
  }

  // .Protocol.StatInfo statInfo = 4;
  if (this->_internal_has_statinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::statinfo(this),
        _Internal::statinfo(this).GetCachedSize(), target, stream);
  }

  // bool isEdge = 5;
  if (this->_internal_isedge() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_isedge(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.ObjectInfo)
  return target;
}

size_t ObjectInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.ObjectInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .Protocol.PositionInfo posInfo = 3;
  if (this->_internal_has_posinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.posinfo_);
  }

  // .Protocol.StatInfo statInfo = 4;
  if (this->_internal_has_statinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.statinfo_);
  }

  // int32 objectId = 1;
  if (this->_internal_objectid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_objectid());
  }

  // bool isEdge = 5;
  if (this->_internal_isedge() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ObjectInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ObjectInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ObjectInfo::GetClassData() const { return &_class_data_; }


void ObjectInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ObjectInfo*>(&to_msg);
  auto& from = static_cast<const ObjectInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.ObjectInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_posinfo()) {
    _this->_internal_mutable_posinfo()->::Protocol::PositionInfo::MergeFrom(
        from._internal_posinfo());
  }
  if (from._internal_has_statinfo()) {
    _this->_internal_mutable_statinfo()->::Protocol::StatInfo::MergeFrom(
        from._internal_statinfo());
  }
  if (from._internal_objectid() != 0) {
    _this->_internal_set_objectid(from._internal_objectid());
  }
  if (from._internal_isedge() != 0) {
    _this->_internal_set_isedge(from._internal_isedge());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ObjectInfo::CopyFrom(const ObjectInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.ObjectInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectInfo::IsInitialized() const {
  return true;
}

void ObjectInfo::InternalSwap(ObjectInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ObjectInfo, _impl_.isedge_)
      + sizeof(ObjectInfo::_impl_.isedge_)
      - PROTOBUF_FIELD_OFFSET(ObjectInfo, _impl_.posinfo_)>(
          reinterpret_cast<char*>(&_impl_.posinfo_),
          reinterpret_cast<char*>(&other->_impl_.posinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ObjectInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[27]);
}

// ===================================================================

class PositionInfo::_Internal {
 public:
};

PositionInfo::PositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.PositionInfo)
}
PositionInfo::PositionInfo(const PositionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PositionInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.state_){}
    , decltype(_impl_.movedir_){}
    , decltype(_impl_.posx_){}
    , decltype(_impl_.posy_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.state_, &from._impl_.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.posy_) -
    reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.posy_));
  // @@protoc_insertion_point(copy_constructor:Protocol.PositionInfo)
}

inline void PositionInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.state_){0}
    , decltype(_impl_.movedir_){0}
    , decltype(_impl_.posx_){0}
    , decltype(_impl_.posy_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PositionInfo::~PositionInfo() {
  // @@protoc_insertion_point(destructor:Protocol.PositionInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PositionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PositionInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PositionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.PositionInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.posy_) -
      reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.posy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PositionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.CreatureState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_state(static_cast<::Protocol::CreatureState>(val));
        } else
          goto handle_unusual;
        continue;
      // .Protocol.MoveDir moveDir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_movedir(static_cast<::Protocol::MoveDir>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 posX = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.posx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 posY = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.posy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PositionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.PositionInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.CreatureState state = 1;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // .Protocol.MoveDir moveDir = 2;
  if (this->_internal_movedir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_movedir(), target);
  }

  // int32 posX = 3;
  if (this->_internal_posx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_posx(), target);
  }

  // int32 posY = 4;
  if (this->_internal_posy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_posy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.PositionInfo)
  return target;
}

size_t PositionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.PositionInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Protocol.CreatureState state = 1;
  if (this->_internal_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  // .Protocol.MoveDir moveDir = 2;
  if (this->_internal_movedir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_movedir());
  }

  // int32 posX = 3;
  if (this->_internal_posx() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_posx());
  }

  // int32 posY = 4;
  if (this->_internal_posy() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_posy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PositionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PositionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PositionInfo::GetClassData() const { return &_class_data_; }


void PositionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PositionInfo*>(&to_msg);
  auto& from = static_cast<const PositionInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.PositionInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_movedir() != 0) {
    _this->_internal_set_movedir(from._internal_movedir());
  }
  if (from._internal_posx() != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  if (from._internal_posy() != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PositionInfo::CopyFrom(const PositionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.PositionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionInfo::IsInitialized() const {
  return true;
}

void PositionInfo::InternalSwap(PositionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PositionInfo, _impl_.posy_)
      + sizeof(PositionInfo::_impl_.posy_)
      - PROTOBUF_FIELD_OFFSET(PositionInfo, _impl_.state_)>(
          reinterpret_cast<char*>(&_impl_.state_),
          reinterpret_cast<char*>(&other->_impl_.state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PositionInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[28]);
}

// ===================================================================

class StatInfo::_Internal {
 public:
};

StatInfo::StatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.StatInfo)
}
StatInfo::StatInfo(const StatInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.speedlvl_){}
    , decltype(_impl_.power_){}
    , decltype(_impl_.availbubble_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.speedlvl_, &from._impl_.speedlvl_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.availbubble_) -
    reinterpret_cast<char*>(&_impl_.speedlvl_)) + sizeof(_impl_.availbubble_));
  // @@protoc_insertion_point(copy_constructor:Protocol.StatInfo)
}

inline void StatInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.speedlvl_){0}
    , decltype(_impl_.power_){0}
    , decltype(_impl_.availbubble_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatInfo::~StatInfo() {
  // @@protoc_insertion_point(destructor:Protocol.StatInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.StatInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.speedlvl_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.availbubble_) -
      reinterpret_cast<char*>(&_impl_.speedlvl_)) + sizeof(_impl_.availbubble_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 speedLvl = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.speedlvl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 power = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.power_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 availBubble = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.availbubble_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.StatInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 speedLvl = 1;
  if (this->_internal_speedlvl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_speedlvl(), target);
  }

  // int32 power = 2;
  if (this->_internal_power() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_power(), target);
  }

  // int32 availBubble = 3;
  if (this->_internal_availbubble() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_availbubble(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.StatInfo)
  return target;
}

size_t StatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.StatInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 speedLvl = 1;
  if (this->_internal_speedlvl() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_speedlvl());
  }

  // int32 power = 2;
  if (this->_internal_power() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_power());
  }

  // int32 availBubble = 3;
  if (this->_internal_availbubble() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_availbubble());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatInfo::GetClassData() const { return &_class_data_; }


void StatInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatInfo*>(&to_msg);
  auto& from = static_cast<const StatInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.StatInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_speedlvl() != 0) {
    _this->_internal_set_speedlvl(from._internal_speedlvl());
  }
  if (from._internal_power() != 0) {
    _this->_internal_set_power(from._internal_power());
  }
  if (from._internal_availbubble() != 0) {
    _this->_internal_set_availbubble(from._internal_availbubble());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatInfo::CopyFrom(const StatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.StatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatInfo::IsInitialized() const {
  return true;
}

void StatInfo::InternalSwap(StatInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatInfo, _impl_.availbubble_)
      + sizeof(StatInfo::_impl_.availbubble_)
      - PROTOBUF_FIELD_OFFSET(StatInfo, _impl_.speedlvl_)>(
          reinterpret_cast<char*>(&_impl_.speedlvl_),
          reinterpret_cast<char*>(&other->_impl_.speedlvl_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[29]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Protocol::S_EnterGame*
Arena::CreateMaybeMessage< ::Protocol::S_EnterGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EnterGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_LeaveGame*
Arena::CreateMaybeMessage< ::Protocol::S_LeaveGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_LeaveGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Spawn*
Arena::CreateMaybeMessage< ::Protocol::S_Spawn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Spawn >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Despawn*
Arena::CreateMaybeMessage< ::Protocol::S_Despawn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Despawn >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Move*
Arena::CreateMaybeMessage< ::Protocol::C_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Move*
Arena::CreateMaybeMessage< ::Protocol::S_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Skill*
Arena::CreateMaybeMessage< ::Protocol::C_Skill >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Skill >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_ChangeStat*
Arena::CreateMaybeMessage< ::Protocol::S_ChangeStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_ChangeStat >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Pop*
Arena::CreateMaybeMessage< ::Protocol::S_Pop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Pop >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Trap*
Arena::CreateMaybeMessage< ::Protocol::S_Trap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Trap >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Die*
Arena::CreateMaybeMessage< ::Protocol::S_Die >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Die >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Connected*
Arena::CreateMaybeMessage< ::Protocol::S_Connected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Connected >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Disconnected*
Arena::CreateMaybeMessage< ::Protocol::S_Disconnected >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Disconnected >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_Login*
Arena::CreateMaybeMessage< ::Protocol::C_Login >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_Login >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_Login*
Arena::CreateMaybeMessage< ::Protocol::S_Login >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_Login >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_CreateRoom*
Arena::CreateMaybeMessage< ::Protocol::C_CreateRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_CreateRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_EnterRoom*
Arena::CreateMaybeMessage< ::Protocol::C_EnterRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_EnterRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_EnterRoom*
Arena::CreateMaybeMessage< ::Protocol::S_EnterRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EnterRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_RoomPlayerList*
Arena::CreateMaybeMessage< ::Protocol::S_RoomPlayerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_RoomPlayerList >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_LeaveRoom*
Arena::CreateMaybeMessage< ::Protocol::C_LeaveRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_LeaveRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_LeaveRoom*
Arena::CreateMaybeMessage< ::Protocol::S_LeaveRoom >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_LeaveRoom >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_StartGame*
Arena::CreateMaybeMessage< ::Protocol::C_StartGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_StartGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_StartGame*
Arena::CreateMaybeMessage< ::Protocol::S_StartGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_StartGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::C_EnterGame*
Arena::CreateMaybeMessage< ::Protocol::C_EnterGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::C_EnterGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::S_EndGame*
Arena::CreateMaybeMessage< ::Protocol::S_EndGame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::S_EndGame >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::RoomInfo*
Arena::CreateMaybeMessage< ::Protocol::RoomInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::RoomInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::GameSessionInfo*
Arena::CreateMaybeMessage< ::Protocol::GameSessionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::GameSessionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::ObjectInfo*
Arena::CreateMaybeMessage< ::Protocol::ObjectInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::ObjectInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::PositionInfo*
Arena::CreateMaybeMessage< ::Protocol::PositionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::PositionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::StatInfo*
Arena::CreateMaybeMessage< ::Protocol::StatInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::StatInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
